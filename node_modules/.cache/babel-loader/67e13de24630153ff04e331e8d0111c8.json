{"ast":null,"code":"import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\n\n/**\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\n */\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nexport const events = [eventPopstate, eventPushState, eventReplaceState];\nexport default (function () {\n  let {\n    base = \"\"\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [{\n    path,\n    search\n  }, update] = useState(() => ({\n    path: currentPathname(base),\n    search: location.search\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n  const prevHash = useRef(path + search);\n  useEffect(() => {\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      const search = location.search;\n      const hash = pathname + search;\n      if (prevHash.current !== hash) {\n        prevHash.current = hash;\n        update({\n          path: pathname,\n          search\n        });\n      }\n    };\n    events.forEach(e => addEventListener(e, checkForUpdates));\n\n    // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n    checkForUpdates();\n    return () => events.forEach(e => removeEventListener(e, checkForUpdates));\n  }, [base]);\n\n  // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  const navigate = useCallback(function (to) {\n    let {\n      replace = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return history[replace ? eventReplaceState : eventPushState](null, \"\",\n    // handle nested routers and absolute paths\n    to[0] === \"~\" ? to.slice(1) : base + to);\n  }, [base]);\n  return [path, navigate];\n});\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\nif (typeof history !== \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n      dispatchEvent(event);\n      return result;\n    };\n  }\n}\nconst currentPathname = function (base) {\n  let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : location.pathname;\n  return !path.toLowerCase().indexOf(base.toLowerCase()) ? path.slice(base.length) || \"/\" : \"~\" + path;\n};","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","eventPopstate","eventPushState","eventReplaceState","events","base","path","search","update","currentPathname","location","prevHash","checkForUpdates","pathname","hash","current","forEach","e","addEventListener","removeEventListener","navigate","to","replace","history","slice","type","original","result","apply","arguments","event","Event","dispatchEvent","toLowerCase","indexOf","length"],"sources":["C:/Users/yubor/Desktop/projects/gighy-api/node_modules/wouter/use-location.js"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from \"./react-deps.js\";\n\n/**\n * History API docs @see https://developer.mozilla.org/en-US/docs/Web/API/History\n */\nconst eventPopstate = \"popstate\";\nconst eventPushState = \"pushState\";\nconst eventReplaceState = \"replaceState\";\nexport const events = [eventPopstate, eventPushState, eventReplaceState];\n\nexport default ({ base = \"\" } = {}) => {\n  const [{ path, search }, update] = useState(() => ({\n    path: currentPathname(base),\n    search: location.search,\n  })); // @see https://reactjs.org/docs/hooks-reference.html#lazy-initial-state\n  const prevHash = useRef(path + search);\n\n  useEffect(() => {\n    // this function checks if the location has been changed since the\n    // last render and updates the state only when needed.\n    // unfortunately, we can't rely on `path` value here, since it can be stale,\n    // that's why we store the last pathname in a ref.\n    const checkForUpdates = () => {\n      const pathname = currentPathname(base);\n      const search = location.search;\n      const hash = pathname + search;\n\n      if (prevHash.current !== hash) {\n        prevHash.current = hash;\n        update({ path: pathname, search });\n      }\n    };\n\n    events.forEach((e) => addEventListener(e, checkForUpdates));\n\n    // it's possible that an update has occurred between render and the effect handler,\n    // so we run additional check on mount to catch these updates. Based on:\n    // https://gist.github.com/bvaughn/e25397f70e8c65b0ae0d7c90b731b189\n    checkForUpdates();\n\n    return () => events.forEach((e) => removeEventListener(e, checkForUpdates));\n  }, [base]);\n\n  // the 2nd argument of the `useLocation` return value is a function\n  // that allows to perform a navigation.\n  //\n  // the function reference should stay the same between re-renders, so that\n  // it can be passed down as an element prop without any performance concerns.\n  const navigate = useCallback(\n    (to, { replace = false } = {}) =>\n      history[replace ? eventReplaceState : eventPushState](\n        null,\n        \"\",\n        // handle nested routers and absolute paths\n        to[0] === \"~\" ? to.slice(1) : base + to\n      ),\n    [base]\n  );\n\n  return [path, navigate];\n};\n\n// While History API does have `popstate` event, the only\n// proper way to listen to changes via `push/replaceState`\n// is to monkey-patch these methods.\n//\n// See https://stackoverflow.com/a/4585031\nif (typeof history !== \"undefined\") {\n  for (const type of [eventPushState, eventReplaceState]) {\n    const original = history[type];\n\n    history[type] = function () {\n      const result = original.apply(this, arguments);\n      const event = new Event(type);\n      event.arguments = arguments;\n\n      dispatchEvent(event);\n      return result;\n    };\n  }\n}\n\nconst currentPathname = (base, path = location.pathname) =>\n  !path.toLowerCase().indexOf(base.toLowerCase())\n    ? path.slice(base.length) || \"/\"\n    : \"~\" + path;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}